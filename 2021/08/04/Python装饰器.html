<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Python装饰器</title>
    <script type="text/javascript" src="/assets/js/prism.js"></script>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <script type="text/javascript" src="/assets/js/jquery-3.6.0.js"></script>
    <script src="/assets/js/scrollnav.min.umd.js"></script>
  </head>
  <body>
    <div class="wrapper">
      <div class="clearfloat">
        <nav class="navbar">
    <!-- <a href="/" >
        Home
    </a>
    <a href="/about.html" >
        About
    </a> -->
    
        <!-- <a href="https://github.com/Zhniing"  target="_self"> -->
        <a href="https://github.com/Zhniing" target="_blank">
            Github
        </a>
    
        <!-- <a href="/about.html"  target="_self"> -->
        <a href="/about.html" target="_self">
            About
        </a>
    
        <!-- <a href="/games/hiker"  target="_self"> -->
        <a href="/games/hiker" target="_self">
            Game
        </a>
    
        <!-- <a href="/"  target="_self"> -->
        <a href="/" target="_self">
            Home
        </a>
    
</nav>
      </div>
      <base target="_blank"> <!-- 仅post页面的a标签为_blank -->

<h1>Python装饰器</h1>
<!-- <p>Posted on 04 Aug 2021, Last updated: </p> -->
<!-- <p>发表于 2021 年 08 月 04 日 | 更新于 </p> -->
<p>发布于 2021 年 08 月 04 日  | 更新于 2021 年 08 月 17 日 </p>

<div class="post_content">
    <h1 id="概述">概述</h1>

<p>装饰器<strong>本质</strong>就是一个语法糖<strong>@</strong>，执行固定的操作：用<code class="language-plaintext highlighter-rouge">decorator(obj)</code>的返回值替换<code class="language-plaintext highlighter-rouge">obj</code>这个名字，即<code class="language-plaintext highlighter-rouge">obj = decorator(obj)</code>。<em>扩展功能</em>是通过python的其他特性（如闭包）实现的。</p>

<h1 id="规则">规则</h1>

<ul>
  <li>被装饰者<code class="language-plaintext highlighter-rouge">obj</code>只能是<strong>函数</strong>或者<strong>类</strong>
</li>
  <li>只要<code class="language-plaintext highlighter-rouge">decorator</code>是一个<strong>可调用</strong>对象就行，因此<em>函数</em>和<em>类</em>都可以作为装饰器</li>
  <li>
<code class="language-plaintext highlighter-rouge">decorator</code><strong>返回值</strong>理论上没有限制，但通常都会<strong>调用</strong>被装饰对象，因此返回值一般也是可调用对象</li>
</ul>

<h1 id="流程">流程</h1>

<ol>
  <li>
<em>调用</em><strong>装饰器</strong>，参数为<strong>被装饰者</strong>：<code class="language-plaintext highlighter-rouge">decorator(obj)</code>，执行装饰器内部代码</li>
  <li>
<em>返回</em>装饰后的对象，替换被装饰者，使<code class="language-plaintext highlighter-rouge">obj</code>指向装饰器返回的对象</li>
</ol>

<p>分别以<strong>装饰器</strong>和<strong>被装饰者</strong>的视角来看：</p>

<ul>
  <li>装饰器
    <ol>
      <li>函数：正常<em>调用</em>函数，<em>返回</em>一般也是函数</li>
      <li>类：<em>调用</em>类的<code class="language-plaintext highlighter-rouge">__init__</code>方法，<em>返回</em>一个<strong>实例对象</strong>；实现类的<code class="language-plaintext highlighter-rouge">__call__</code>方法，使其成为可调用对象</li>
    </ol>
  </li>
  <li>被装饰者
    <ol>
      <li>
        <p>普通函数：装饰器<em>返回</em>的<strong>对象</strong>只要可调用就行</p>
      </li>
      <li>
        <p>类：装饰器<em>返回</em>的<strong>对象</strong>只要可调用就行，调用的返回值理论上没有限制，但<em>通常</em>是一个<em>扩展后的类</em>的实例对象</p>
      </li>
      <li>
        <p>实例函数（成员函数？）：装饰器必须<em>返回</em><strong>函数</strong>；如果返回对象，那在实例化时，不会变成<code class="language-plaintext highlighter-rouge">bound method</code>（绑定方法？），也就无法<strong>传self进去</strong></p>

        <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>  <span class="c1"># 用函数来定义装饰器
</span>    <span class="k">def</span> <span class="nf">warpper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># (*args, **kwargs) 保持参数一致的最简单的方法
</span>        <span class="k">return</span> <span class="nf">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">warpper</span>

<span class="k">class</span> <span class="nc">ClassDecorator</span><span class="p">:</span>  <span class="c1"># 用类来定义装饰器
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@decorator</span>  <span class="c1"># 把对象的__call__方法包装成函数，就能变成bound method了
</span>    <span class="nd">@ClassDecorator</span>  <span class="c1"># 返回对象，不能变成bound method
</span>    <span class="k">def</span> <span class="nf">instance_method</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'call instance_fun'</span><span class="p">)</span>

    <span class="nd">@ClassDecorator</span>  <span class="c1"># 返回对象，不能变成bound method
</span>    <span class="k">def</span> <span class="nf">instance_obj</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'call instance_fun'</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">instance_method</span><span class="p">)</span>  <span class="c1"># &lt;bound method decorator.&lt;locals&gt;.warpper of &lt;__main__.A object at 0x7fc85fcabbb0&gt;&gt;
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">instance_obj</span><span class="p">)</span>  <span class="c1"># &lt;__main__.ClassDecorator object at 0x7fc85fd26b20&gt;
</span></code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ul>

<h1 id="用途">用途</h1>

<ol>
  <li>不修改函数调用方式的前提下，在函数的<strong>前后</strong>添加功能（如：计算函数执行时间）<a href="https://www.cnblogs.com/funyou/p/11937833.html">reference(内容有错误)</a>
</li>
  <li>注册器<strong>类</strong>，往对象中注册函数，通过字符串调用 <a href="https://blog.csdn.net/Johnson_star/article/details/115473449">reference</a>
</li>
  <li>单例类/单例模式：<strong>仅有一个</strong>实例对象的类</li>
</ol>

<h1 id="装饰器代码的执行时机">装饰器代码的执行时机</h1>

<p>在被装饰对象<strong>定义或初始化完成后</strong>，就会进行装饰（执行装饰器），<strong>而不是</strong>等到调用被装饰对象时才进行装饰</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>  <span class="c1"># 用函数来定义装饰器
</span>    <span class="n">name</span> <span class="o">=</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">'__qualname__'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span><span class="p">.</span><span class="n">__qualname__</span> <span class="ow">or</span> <span class="n">obj</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'call decorator, obj is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">warpper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># (*args, **kwargs) 保持参数一致的最简单的方法
</span>        <span class="nf">print</span><span class="p">(</span><span class="s">'call decorator-&gt;warpper'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">warpper</span>

<span class="k">class</span> <span class="nc">ClassDecorator</span><span class="p">:</span>  <span class="c1"># 用类来定义装饰器
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nf">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">'__qualname__'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span><span class="p">.</span><span class="n">__qualname__</span> <span class="ow">or</span> <span class="n">obj</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'call ClassDecorator, obj is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'call ClassDecorator-&gt;__call__'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1"># 定义 my_fun1 然后执行 decorator(my_fun1)
</span><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">my_fun1</span><span class="p">():</span>  <span class="c1"># 用于装饰函数 my_fun1 = decorator(my_fun1) 将 my_fun1 替换为包装后的函数
</span>    <span class="nf">print</span><span class="p">(</span><span class="s">'call my_fun1'</span><span class="p">)</span>

<span class="c1"># 定义 my_fun2 然后执行 ClassDecorator(my_fun2)
</span><span class="nd">@ClassDecorator</span>
<span class="k">def</span> <span class="nf">my_fun2</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">'call my_fun2'</span><span class="p">)</span>

<span class="c1"># 初始化 A 然后执行 decorator(A)
</span><span class="nd">@decorator</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  <span class="c1"># 用于装饰类 A = decorator(A)
</span>    <span class="nf">print</span><span class="p">(</span><span class="s">'init class A begin...'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'call A.__init__'</span><span class="p">)</span>

    <span class="nd">@decorator</span>  <span class="c1"># 返回函数，可以变成bound method
</span>    <span class="k">def</span> <span class="nf">instance_fun1</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'call instance_fun1'</span><span class="p">)</span>

    <span class="nd">@decorator</span>  <span class="c1"># 把对象的__call__方法包装成函数，就能变成bound method了
</span>    <span class="nd">@ClassDecorator</span>  <span class="c1"># 返回对象，不能变成bound method
</span>    <span class="k">def</span> <span class="nf">instance_fun2</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'call instance_fun2'</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="s">'init class A end...'</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="s">'before call my_fun1'</span><span class="p">)</span>
<span class="nf">my_fun1</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'before call my_fun2'</span><span class="p">)</span>
<span class="nf">my_fun2</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="n">a</span><span class="p">.</span><span class="nf">instance_fun1</span><span class="p">()</span>
</code></pre></div></div>

<p>运行结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call decorator, obj is my_fun1
call ClassDecorator, obj is my_fun2
init class A begin...
call decorator, obj is A.instance_fun1
call ClassDecorator, obj is A.instance_fun2
call decorator, obj is &lt;__main__.ClassDecorator object at 0x7fc79d1bf850&gt;
init class A end...
call decorator, obj is A
before call my_fun1
call decorator-&gt;warpper
call my_fun1
before call my_fun2
call ClassDecorator-&gt;__call__
call my_fun2
call decorator-&gt;warpper
call A.__init__
call decorator-&gt;warpper
call instance_fun1
</code></pre></div></div>

<h1 id="总结">总结</h1>

<p>调用被装饰者<code class="language-plaintext highlighter-rouge">obj</code>时，可以把<code class="language-plaintext highlighter-rouge">obj</code>看成是<code class="language-plaintext highlighter-rouge">decorator</code>的<strong>返回值</strong></p>

<h1 id="参考">参考</h1>

<ol>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/44667584">Python 小技巧 —— 用类写装饰器</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-3-%E7%A5%9E%E5%A5%87%E5%8F%88%E7%BE%8E%E5%A5%BD%E7%9A%84-decorator-%E5%97%B7%E5%97%9A-6559edc87bc0">reference</a></p>
  </li>
</ol>

</div>
    </div>
    <script>
      const ct = document.querySelector('.post_content');  //".post-content"指向文章内容所在的div，需根据实际情况修改
      scrollnav.init(ct, {
          debug: false,
          easingStyle: 'linear',
          //section为一级目录，subsection为二级目录
          sections: ($('.post_content > h1').length>0) ? 'h1' : 'h2',
          subSections: ($('.post_content > h1').length>0) ? 'h2' : 'h3',
      });
    </script>
    <script type="text/javascript">
      $('pre').addClass("line-numbers").css("white-space", "pre-wrap");
    </script>
  </body>
</html>
