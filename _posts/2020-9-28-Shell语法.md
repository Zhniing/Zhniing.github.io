---
categories:
- Linux
- Shell
last-updated-date: 2021-11-15 17:03:42.500000+08:00
layout: post
---

# Bash

## 首行

脚本第一行`#!<shell path> [options]`指定用哪个shell来执行该脚本，**常用选项**(options)如下：

`-e`：表示任意指令返回非真值（非0值）时结束脚本，写作`#!/bin/bash -e`

更多选项参考`bash -c "help set"`，[online man: set(1p)](https://man7.org/linux/man-pages/man1/set.1p.html)更详细

## 条件表达式

条件表达式主要有几种形式：[ref](https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs)

- `test EXPRESSION`
- `[ EXPRESSION ]`
- `[[ EXPRESSION ]]`
- `(( EXPRESSION ))`

[Test Constructs](https://tldp.org/LDP/abs/html/testconstructs.html#DBLPRX)

### [ 和 test

> `[` is another name for the traditional `test` command.

关于`if [ EXPRESSION ]`，左右方括号必须要隔空格的原因是：Shell将`[`当作一条**指令**:sweat_smile:

```bash
$ which [
[: shell built-in command
$ whereis [
[: /usr/bin/[ /usr/share/man/man1/[.1.gz
$ ls -l /usr/bin/\[
-rwxr-xr-x 1 root root 59736 Sep  5  2019 '/usr/bin/['
# 可以看到'['是一个可执行文件
```

因此，也可以直接在**交互Shell**中测试`[ EXPRESSION ]`的返回值(`$?`)

由于`&&`和`||`被Shell用于*连接两条命令*，因此，`[ EXPRESSION ]`中出现`&&`和`||`时，会被认为是第二条指令，然后报错找不到`]`

```bash
$ [ 1 && 2 ] # False(返回值非0)
[: ']' expected # 报错
$ [ 1 ] && [ 2 ] # True(返回值为0)
```

### [[

`[[`是`test`命令的一种改版，可以使用`&&`和`||`

正则匹配：使用`=~`来正则地比较字符串（好像只用`=`也支持正则），*字符串在左，正则模式在右*

### ((

主要用于**算数运算**，支持C-style的自增自减(++/--)

[The Double-Parentheses Construct](https://tldp.org/LDP/abs/html/dblparens.html)

[ARITHMETIC EVALUATION](https://www.man7.org/linux/man-pages/man1/bash.1.html#ARITHMETIC_EVALUATION)

```bash
a=$(( 3 + 5 ))  # shell里面这种‘a’和‘=’分开的话，一般情况下a会被当成指令
(( a++ ))
echo $a  # 9
```

### test 操作符

更多参见`man bash`的**[CONDITIONAL EXPRESSIONS](https://www.man7.org/linux/man-pages/man1/bash.1.html#CONDITIONAL_EXPRESSIONS)**章节

- 字符串

  `-z`字符串长度为0返回true

  `-n`字符串长度**不**为0返回true

- 文件

  `-e`文件存在

  `-d`文件存在&是目录

  `-f`文件存在&是普通文件（非目录或设备文件）
  
- **数值**比较

  :bangbang: 在`[[`中*必须*使用`-gt`这类操作符，使用`<`这类符号会被当作**字符串比较**

  在`((`中，可以用`<`符号
  
  ```bash
  [[ 2 < 10 ]]  # False (exit status 1)
  (( 2 < 10 ))  # True (exit status 0)
  ```

## 参数扩展

`${parameter:-word}`：使用**默认值**，如果`parameter`不存在，就以`word`作为其值

更多参考`man bash`的[Parameter Expansion](https://www.man7.org/linux/man-pages/man1/bash.1.html#:~:text=in%20posix%20mode.-,Parameter%20Expansion,-The%20%60%24%27%20character%20introduces)小节

## 杂项

`$?`：这个变量保存了上一条**指令**的**返回值**

**赋值**`=`两边不能有*空格*，**判断**`=`两边必须要有*空格*

判断是否传入参数（参数是否存在）：直接`$1`

函数获取返回值`$(function name)`

全局变量？？？

# 管道命令执行顺序

用管道连接的命令是**同时**执行的

比如`ps a | grep bash`的执行结果中，会出现`grep`的进程

```shell
➜  ~ ps a | grep bash
  263 pts/0    Ss     0:00 -bash
  811 pts/0    S+     0:00 grep bash
```

说明在`ps`在执行打印进程信息的时候，`grep`也在执行了，也就是说`ps`和`grep`是同时执行的

只不过`grep`执行到需要输入的时候就会停下来(状态S+)，等待I/O（`ps`的标准输出）

# Zsh和Bash的兼容性问题

Zsh并不是完全兼容Bash

如果要**完全兼容**，使用`emulate bash` 或文件开头添加`#!/usr/bin/bash`（直接指定用bash执行该脚本）

目前遇到的不兼容情况：

1. 条件表达式中，判断相等，Bash支持双等号`==`，而Zsh只支持单等号`=`
2. curl命令无法正常运行

Shell中的**字符串变量**更像是C语言中的宏定义，运行时直接替换到目标位置，如果包含空格就容易引起歧义，因此通常将变量写在双引号内`"$a"`。

算数运算在((...))中进行，如`((i=i+1))`